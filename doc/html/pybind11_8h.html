<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>filepattern: lib/pybind11/include/pybind11/pybind11.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">filepattern
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_95df9e99ec2147d79d3c0ac3b874c0b3.html">lib</a></li><li class="navelem"><a class="el" href="dir_6aca9136ace84e0f3fd30075a2237193.html">pybind11</a></li><li class="navelem"><a class="el" href="dir_e07c0b55d9b6c6c87fa5f4ceeb072eda.html">include</a></li><li class="navelem"><a class="el" href="dir_785f43808243cd0dcaeb5d580d717308.html">pybind11</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pybind11.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="attr_8h_source.html">attr.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="gil_8h_source.html">gil.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="options_8h_source.html">options.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="class_8h_source.html">detail/class.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="init_8h_source.html">detail/init.h</a>&quot;</code><br/>
<code>#include &lt;cstdlib&gt;</code><br/>
<code>#include &lt;memory&gt;</code><br/>
<code>#include &lt;new&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;utility&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
</div>
<p><a href="pybind11_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpp__function.html">cpp_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object.  <a href="classcpp__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpp__function_1_1InitializingFunctionRecordDeleter.html">cpp_function::InitializingFunctionRecordDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcpp__function_1_1strdup__guard.html">cpp_function::strdup_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmodule__.html">module_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for Python extension modules.  <a href="classmodule__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmodule___1_1module__def.html">module_::module_def</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeneric__type.html">generic_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic support for creating new Python heap types.  <a href="classgeneric__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__operator__delete.html">has_operator_delete&lt; T, SFINAE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__operator__delete_3_01T_00_01void__t_3_01decltype_07static__cast_3_01void_07_5_08_07voabb3e146de0106c936d854495169cfdd.html">has_operator_delete&lt; T, void_t&lt; decltype(static_cast&lt; void(*)(void *)&gt;(T::operator delete))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__operator__delete__size.html">has_operator_delete_size&lt; T, SFINAE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhas__operator__delete__size_3_01T_00_01void__t_3_01decltype_07static__cast_3_01void_07_5_0907a72d5a82a7720aaefcb0399d3d6f3.html">has_operator_delete_size&lt; T, void_t&lt; decltype(static_cast&lt; void(*)(void *, size_t)&gt;(T::operator delete))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classclass__.html">class_&lt; type_, options &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenum__base.html">enum_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer.html">equivalent_integer&lt; is_signed, length &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01true_00_011_01_4.html">equivalent_integer&lt; true, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01false_00_011_01_4.html">equivalent_integer&lt; false, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01true_00_012_01_4.html">equivalent_integer&lt; true, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01false_00_012_01_4.html">equivalent_integer&lt; false, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01true_00_014_01_4.html">equivalent_integer&lt; true, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01false_00_014_01_4.html">equivalent_integer&lt; false, 4 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01true_00_018_01_4.html">equivalent_integer&lt; true, 8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structequivalent__integer_3_01false_00_018_01_4.html">equivalent_integer&lt; false, 8 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classenum__.html">enum_&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds C++ enumerations and enumeration classes to Python.  <a href="classenum__.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiterator__state.html">iterator_state&lt; Access, Policy, Iterator, Sentinel, ValueType, Extra &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structiterator__access.html">iterator_access&lt; Iterator, SFINAE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiterator__key__access.html">iterator_key_access&lt; Iterator, SFINAE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiterator__value__access.html">iterator_value_access&lt; Iterator, SFINAE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexception.html">exception&lt; type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a89ef98b3c1b0cd785d6f37dad8fff8b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a89ef98b3c1b0cd785d6f37dad8fff8b3">PYBIND11_STD_LAUNDER</a></td></tr>
<tr class="separator:a89ef98b3c1b0cd785d6f37dad8fff8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c836caf81bd65cf45e924bbd70eccb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ab9c836caf81bd65cf45e924bbd70eccb">PYBIND11_HAS_STD_LAUNDER</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab9c836caf81bd65cf45e924bbd70eccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd9db526f4b1c2d8b4864eb4f2b1eb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a2fd9db526f4b1c2d8b4864eb4f2b1eb5">PYBIND11_COMPAT_STRDUP</a>&#160;&#160;&#160;strdup</td></tr>
<tr class="separator:a2fd9db526f4b1c2d8b4864eb4f2b1eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adade02474502609b96c61b2054218bcf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#adade02474502609b96c61b2054218bcf">PYBIND11_ENUM_OP_STRICT</a>(op, expr, strict_behavior)</td></tr>
<tr class="separator:adade02474502609b96c61b2054218bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fd1ef72c39ba18ce5223e17d8a1caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a91fd1ef72c39ba18ce5223e17d8a1caa">PYBIND11_ENUM_OP_CONV</a>(op, expr)</td></tr>
<tr class="separator:a91fd1ef72c39ba18ce5223e17d8a1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af9d4d51bae345dfc06b6c6fcfd9fdb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a1af9d4d51bae345dfc06b6c6fcfd9fdb">PYBIND11_ENUM_OP_CONV_LHS</a>(op, expr)</td></tr>
<tr class="separator:a1af9d4d51bae345dfc06b6c6fcfd9fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc16e5b178730313f1372d6e1be4e414"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#acc16e5b178730313f1372d6e1be4e414">PYBIND11_THROW</a>&#160;&#160;&#160;throw type_error(&quot;Expected an enumeration of matching type!&quot;);</td></tr>
<tr class="separator:acc16e5b178730313f1372d6e1be4e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc6ec674e602ee43d9e1d4b5caf316f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">PYBIND11_OVERRIDE_IMPL</a>(ret_type, cname, <a class="el" href="structname.html">name</a>,...)</td></tr>
<tr class="separator:a4cc6ec674e602ee43d9e1d4b5caf316f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9a375d2743469e77032be644eb2c6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#aaa9a375d2743469e77032be644eb2c6d">PYBIND11_OVERRIDE_NAME</a>(ret_type, cname, <a class="el" href="structname.html">name</a>, fn,...)</td></tr>
<tr class="separator:aaa9a375d2743469e77032be644eb2c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61d0f2218e6017d8eb42eef8731c921"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ab61d0f2218e6017d8eb42eef8731c921">PYBIND11_OVERRIDE_PURE_NAME</a>(ret_type, cname, <a class="el" href="structname.html">name</a>, fn,...)</td></tr>
<tr class="separator:ab61d0f2218e6017d8eb42eef8731c921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676997b992463eaa9f402b33a8aca82f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a676997b992463eaa9f402b33a8aca82f">PYBIND11_OVERRIDE</a>(ret_type, cname, fn,...)&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#aaa9a375d2743469e77032be644eb2c6d">PYBIND11_OVERRIDE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), #fn, fn, __VA_ARGS__)</td></tr>
<tr class="separator:a676997b992463eaa9f402b33a8aca82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd1c7b6ad2aad2fc781c337c8adc2d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a3cd1c7b6ad2aad2fc781c337c8adc2d1">PYBIND11_OVERRIDE_PURE</a>(ret_type, cname, fn,...)&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#ab61d0f2218e6017d8eb42eef8731c921">PYBIND11_OVERRIDE_PURE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), #fn, fn, __VA_ARGS__)</td></tr>
<tr class="separator:a3cd1c7b6ad2aad2fc781c337c8adc2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad225e789a43a99757532d624f794b377"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ad225e789a43a99757532d624f794b377">PYBIND11_OVERLOAD_INT</a>(ret_type, cname, <a class="el" href="structname.html">name</a>,...)&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">PYBIND11_OVERRIDE_IMPL</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="el" href="structname.html">name</a>, __VA_ARGS__)</td></tr>
<tr class="separator:ad225e789a43a99757532d624f794b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5ebc119f4e7ca7ccb05d9d1f64d547"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a6a5ebc119f4e7ca7ccb05d9d1f64d547">PYBIND11_OVERLOAD_NAME</a>(ret_type, cname, <a class="el" href="structname.html">name</a>, fn,...)&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#aaa9a375d2743469e77032be644eb2c6d">PYBIND11_OVERRIDE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="el" href="structname.html">name</a>, fn, __VA_ARGS__)</td></tr>
<tr class="separator:a6a5ebc119f4e7ca7ccb05d9d1f64d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b952e976930f2149eec9d0eb450100"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a52b952e976930f2149eec9d0eb450100">PYBIND11_OVERLOAD_PURE_NAME</a>(ret_type, cname, <a class="el" href="structname.html">name</a>, fn,...)&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#ab61d0f2218e6017d8eb42eef8731c921">PYBIND11_OVERRIDE_PURE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="el" href="structname.html">name</a>, fn, __VA_ARGS__);</td></tr>
<tr class="separator:a52b952e976930f2149eec9d0eb450100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554e6c4e025a0a1a1d8b30998144e386"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a554e6c4e025a0a1a1d8b30998144e386">PYBIND11_OVERLOAD</a>(ret_type, cname, fn,...)&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#a676997b992463eaa9f402b33a8aca82f">PYBIND11_OVERRIDE</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), fn, __VA_ARGS__)</td></tr>
<tr class="separator:a554e6c4e025a0a1a1d8b30998144e386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf72084f40e31c334fd2d2b0161e959b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#acf72084f40e31c334fd2d2b0161e959b">PYBIND11_OVERLOAD_PURE</a>(ret_type, cname, fn,...)&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#a3cd1c7b6ad2aad2fc781c337c8adc2d1">PYBIND11_OVERRIDE_PURE</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), fn, __VA_ARGS__);</td></tr>
<tr class="separator:acf72084f40e31c334fd2d2b0161e959b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a901866f667bab56f0f47d93c42afb6fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a901866f667bab56f0f47d93c42afb6fc">module</a> = <a class="el" href="classmodule__.html">module_</a></td></tr>
<tr class="separator:a901866f667bab56f0f47d93c42afb6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117a9d990aaecff5ed8c9106fefc61aa"><td class="memTemplParams" colspan="2">template&lt;typename IntLike &gt; </td></tr>
<tr class="memitem:a117a9d990aaecff5ed8c9106fefc61aa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a117a9d990aaecff5ed8c9106fefc61aa">equivalent_integer_t</a> = typename <a class="el" href="structequivalent__integer.html">equivalent_integer</a>&lt; std::is_signed&lt; IntLike &gt;::value, sizeof(IntLike)&gt;::<a class="el" href="classtype.html">type</a></td></tr>
<tr class="separator:a117a9d990aaecff5ed8c9106fefc61aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a371d331d7073d8abc4ca0d54174e3fdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a371d331d7073d8abc4ca0d54174e3fdd">apply_exception_translators</a> (std::forward_list&lt; <a class="el" href="internals_8h.html#a596d5eacb6a7f656d2fa4a241636e223">ExceptionTranslator</a> &gt; &amp;translators)</td></tr>
<tr class="separator:a371d331d7073d8abc4ca0d54174e3fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be04c9e8c8a6833cabae628e2243b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdict.html">dict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga0be04c9e8c8a6833cabae628e2243b6c">globals</a> ()</td></tr>
<tr class="separator:ga0be04c9e8c8a6833cabae628e2243b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55b858834fdd3c6adb5e8b9615b49b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = void_t&lt;decltype(static_cast&lt;void *(*)(size_t)&gt;(T::operator new))&gt;&gt; </td></tr>
<tr class="memitem:ae55b858834fdd3c6adb5e8b9615b49b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ae55b858834fdd3c6adb5e8b9615b49b6">set_operator_new</a> (<a class="el" href="structtype__record.html">type_record</a> *r)</td></tr>
<tr class="memdesc:ae55b858834fdd3c6adb5e8b9615b49b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pointer to operator new if it exists. The cast is needed because it can be overloaded.  <a href="#ae55b858834fdd3c6adb5e8b9615b49b6">More...</a><br/></td></tr>
<tr class="separator:ae55b858834fdd3c6adb5e8b9615b49b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d62802b102a8ac8362eeef769aaad4"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a32d62802b102a8ac8362eeef769aaad4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a32d62802b102a8ac8362eeef769aaad4">set_operator_new</a> (...)</td></tr>
<tr class="separator:a32d62802b102a8ac8362eeef769aaad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9edb48e1b7e9f3cf1dfa835cc39be2"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_t&lt; has_operator_delete&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4f9edb48e1b7e9f3cf1dfa835cc39be2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a4f9edb48e1b7e9f3cf1dfa835cc39be2">call_operator_delete</a> (T *p, <a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>, <a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>)</td></tr>
<tr class="memdesc:a4f9edb48e1b7e9f3cf1dfa835cc39be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call class-specific delete if it exists or global otherwise. Can also be an overload set.  <a href="#a4f9edb48e1b7e9f3cf1dfa835cc39be2">More...</a><br/></td></tr>
<tr class="separator:a4f9edb48e1b7e9f3cf1dfa835cc39be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e61d624540777bbf68662f0c0da0bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a5e61d624540777bbf68662f0c0da0bbf">call_operator_delete</a> (void *p, <a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a> s, <a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a> a)</td></tr>
<tr class="separator:a5e61d624540777bbf68662f0c0da0bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe75675661f805f43391c0f7d00e23c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#aefe75675661f805f43391c0f7d00e23c">add_class_method</a> (<a class="el" href="classobject.html">object</a> &amp;cls, const char *name_, const <a class="el" href="classcpp__function.html">cpp_function</a> &amp;cf)</td></tr>
<tr class="separator:aefe75675661f805f43391c0f7d00e23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133120592be1caf7036580978b5bd6dd"><td class="memTemplParams" colspan="2">template&lt;typename , typename F &gt; </td></tr>
<tr class="memitem:a133120592be1caf7036580978b5bd6dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a133120592be1caf7036580978b5bd6dd">method_adaptor</a> (F &amp;&amp;f) -&gt; decltype(std::forward&lt; F &gt;(f))</td></tr>
<tr class="separator:a133120592be1caf7036580978b5bd6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb45bb8178cd55c41b0f0d84bde00cfe"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename Return , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:adb45bb8178cd55c41b0f0d84bde00cfe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#adb45bb8178cd55c41b0f0d84bde00cfe">method_adaptor</a> (Return(Class::*pmf)(Args...)) -&gt; Return(Derived::*)(Args...)</td></tr>
<tr class="separator:adb45bb8178cd55c41b0f0d84bde00cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c2b15c53478c1154ec995f5f83faf1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ad8c2b15c53478c1154ec995f5f83faf1"><td class="memTemplItemLeft" align="right" valign="top">detail::initimpl::constructor<br class="typebreak"/>
&lt; Args...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ad8c2b15c53478c1154ec995f5f83faf1">init</a> ()</td></tr>
<tr class="memdesc:ad8c2b15c53478c1154ec995f5f83faf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an existing constructor taking arguments Args...  <a href="#ad8c2b15c53478c1154ec995f5f83faf1">More...</a><br/></td></tr>
<tr class="separator:ad8c2b15c53478c1154ec995f5f83faf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d58e6f734e067663b055f7da3b0f2f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a39d58e6f734e067663b055f7da3b0f2f"><td class="memTemplItemLeft" align="right" valign="top">detail::initimpl::alias_constructor<br class="typebreak"/>
&lt; Args...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a39d58e6f734e067663b055f7da3b0f2f">init_alias</a> ()</td></tr>
<tr class="separator:a39d58e6f734e067663b055f7da3b0f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca0a3cdc2264eb2b0d36acd762c8bae"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename Ret  = detail::initimpl::factory&lt;Func&gt;&gt; </td></tr>
<tr class="memitem:a1ca0a3cdc2264eb2b0d36acd762c8bae"><td class="memTemplItemLeft" align="right" valign="top">Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a1ca0a3cdc2264eb2b0d36acd762c8bae">init</a> (Func &amp;&amp;f)</td></tr>
<tr class="memdesc:a1ca0a3cdc2264eb2b0d36acd762c8bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a factory function as a constructor.  <a href="#a1ca0a3cdc2264eb2b0d36acd762c8bae">More...</a><br/></td></tr>
<tr class="separator:a1ca0a3cdc2264eb2b0d36acd762c8bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144961765ca31801e21d87651871934c"><td class="memTemplParams" colspan="2">template&lt;typename CFunc , typename AFunc , typename Ret  = detail::initimpl::factory&lt;CFunc, AFunc&gt;&gt; </td></tr>
<tr class="memitem:a144961765ca31801e21d87651871934c"><td class="memTemplItemLeft" align="right" valign="top">Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a144961765ca31801e21d87651871934c">init</a> (CFunc &amp;&amp;c, AFunc &amp;&amp;a)</td></tr>
<tr class="separator:a144961765ca31801e21d87651871934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d308bb5b6a2dbeb02cd90d90876562"><td class="memTemplParams" colspan="2">template&lt;typename GetState , typename SetState &gt; </td></tr>
<tr class="memitem:a17d308bb5b6a2dbeb02cd90d90876562"><td class="memTemplItemLeft" align="right" valign="top">detail::initimpl::pickle_factory<br class="typebreak"/>
&lt; GetState, SetState &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a17d308bb5b6a2dbeb02cd90d90876562">pickle</a> (GetState &amp;&amp;g, SetState &amp;&amp;s)</td></tr>
<tr class="separator:a17d308bb5b6a2dbeb02cd90d90876562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8fe77ae59b4c20905c50b4221072b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstr.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a4c8fe77ae59b4c20905c50b4221072b8">enum_name</a> (<a class="el" href="classhandle.html">handle</a> arg)</td></tr>
<tr class="separator:a4c8fe77ae59b4c20905c50b4221072b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0b13e3a890001e99f724fef9d285de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="detail_2common_8h.html#a1fb186b7494d5c576d902c0730ecbb71">PYBIND11_NOINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a5d0b13e3a890001e99f724fef9d285de">keep_alive_impl</a> (<a class="el" href="classhandle.html">handle</a> nurse, <a class="el" href="classhandle.html">handle</a> patient)</td></tr>
<tr class="separator:a5d0b13e3a890001e99f724fef9d285de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bda75120c8e859c75dfd2f5a266c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="detail_2common_8h.html#a1fb186b7494d5c576d902c0730ecbb71">PYBIND11_NOINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#aa1bda75120c8e859c75dfd2f5a266c7b">keep_alive_impl</a> (<a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a> Nurse, <a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a> Patient, function_call &amp;call, <a class="el" href="classhandle.html">handle</a> ret)</td></tr>
<tr class="separator:aa1bda75120c8e859c75dfd2f5a266c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29009830196890060d446644b1f7cec"><td class="memItemLeft" align="right" valign="top">std::pair&lt; decltype(<a class="el" href="structinternals.html#a6148bb4956e17d8a61f410cac7227d04">internals::registered_types_py</a>)::<a class="el" href="classiterator.html">iterator</a>, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#aa29009830196890060d446644b1f7cec">all_type_info_get_cache</a> (PyTypeObject *<a class="el" href="classtype.html">type</a>)</td></tr>
<tr class="separator:aa29009830196890060d446644b1f7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416a9cc6f9891390c28bcba008d58225"><td class="memTemplParams" colspan="2">template&lt;typename Access , return_value_policy Policy, typename Iterator , typename Sentinel , typename ValueType , typename... Extra&gt; </td></tr>
<tr class="memitem:a416a9cc6f9891390c28bcba008d58225"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a416a9cc6f9891390c28bcba008d58225">make_iterator_impl</a> (Iterator <a class="el" href="detail_2common_8h.html#a68d7ad23fb8133de9ac3882513135cb2">first</a>, Sentinel <a class="el" href="detail_2common_8h.html#a9fa82a954fe267e5e8dadd9eae434d44">last</a>, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:a416a9cc6f9891390c28bcba008d58225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d3654deacdd79bbdc1feb82955fd30"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = typename detail::iterator_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </td></tr>
<tr class="memitem:ae6d3654deacdd79bbdc1feb82955fd30"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ae6d3654deacdd79bbdc1feb82955fd30">make_iterator</a> (Iterator <a class="el" href="detail_2common_8h.html#a68d7ad23fb8133de9ac3882513135cb2">first</a>, Sentinel <a class="el" href="detail_2common_8h.html#a9fa82a954fe267e5e8dadd9eae434d44">last</a>, Extra &amp;&amp;...extra)</td></tr>
<tr class="memdesc:ae6d3654deacdd79bbdc1feb82955fd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a python iterator from a first and past-the-end C++ InputIterator.  <a href="#ae6d3654deacdd79bbdc1feb82955fd30">More...</a><br/></td></tr>
<tr class="separator:ae6d3654deacdd79bbdc1feb82955fd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba3c96a10f754eb5d59f83aef2b364b"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = typename detail::iterator_key_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </td></tr>
<tr class="memitem:adba3c96a10f754eb5d59f83aef2b364b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#adba3c96a10f754eb5d59f83aef2b364b">make_key_iterator</a> (Iterator <a class="el" href="detail_2common_8h.html#a68d7ad23fb8133de9ac3882513135cb2">first</a>, Sentinel <a class="el" href="detail_2common_8h.html#a9fa82a954fe267e5e8dadd9eae434d44">last</a>, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:adba3c96a10f754eb5d59f83aef2b364b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c05cc3bd4da2516057ca76ab7654dcf"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = typename detail::iterator_value_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </td></tr>
<tr class="memitem:a0c05cc3bd4da2516057ca76ab7654dcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a0c05cc3bd4da2516057ca76ab7654dcf">make_value_iterator</a> (Iterator <a class="el" href="detail_2common_8h.html#a68d7ad23fb8133de9ac3882513135cb2">first</a>, Sentinel <a class="el" href="detail_2common_8h.html#a9fa82a954fe267e5e8dadd9eae434d44">last</a>, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:a0c05cc3bd4da2516057ca76ab7654dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4568dafc7828fa924d63fd6e8e77171"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:aa4568dafc7828fa924d63fd6e8e77171"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#aa4568dafc7828fa924d63fd6e8e77171">make_iterator</a> (Type &amp;value, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:aa4568dafc7828fa924d63fd6e8e77171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5c4912de4a5bd91b09420b946dc5e4"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:abe5c4912de4a5bd91b09420b946dc5e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#abe5c4912de4a5bd91b09420b946dc5e4">make_key_iterator</a> (Type &amp;value, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:abe5c4912de4a5bd91b09420b946dc5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253e7eb1e5fe98a584738fbd34c70f61"><td class="memTemplParams" colspan="2">template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:a253e7eb1e5fe98a584738fbd34c70f61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classiterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a253e7eb1e5fe98a584738fbd34c70f61">make_value_iterator</a> (Type &amp;value, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:a253e7eb1e5fe98a584738fbd34c70f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271a0a8cc9839658c668492cbaa1035a"><td class="memTemplParams" colspan="2">template&lt;typename InputType , typename OutputType &gt; </td></tr>
<tr class="memitem:a271a0a8cc9839658c668492cbaa1035a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a271a0a8cc9839658c668492cbaa1035a">implicitly_convertible</a> ()</td></tr>
<tr class="separator:a271a0a8cc9839658c668492cbaa1035a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13b0934aa2da46dd6969a0ea44adfed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ae13b0934aa2da46dd6969a0ea44adfed">register_exception_translator</a> (<a class="el" href="internals_8h.html#a596d5eacb6a7f656d2fa4a241636e223">ExceptionTranslator</a> &amp;&amp;translator)</td></tr>
<tr class="separator:ae13b0934aa2da46dd6969a0ea44adfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b50172e54731480feea10ec204f003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a39b50172e54731480feea10ec204f003">register_local_exception_translator</a> (<a class="el" href="internals_8h.html#a596d5eacb6a7f656d2fa4a241636e223">ExceptionTranslator</a> &amp;&amp;translator)</td></tr>
<tr class="separator:a39b50172e54731480feea10ec204f003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e05149e1a3c61637211fd554bb856f6"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:a4e05149e1a3c61637211fd554bb856f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classexception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a4e05149e1a3c61637211fd554bb856f6">get_exception_object</a> ()</td></tr>
<tr class="separator:a4e05149e1a3c61637211fd554bb856f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a183883bc97bb26079701a8237e1896"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:a1a183883bc97bb26079701a8237e1896"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classexception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a1a183883bc97bb26079701a8237e1896">register_exception_impl</a> (<a class="el" href="classhandle.html">handle</a> <a class="el" href="structscope.html">scope</a>, const char *<a class="el" href="structname.html">name</a>, <a class="el" href="classhandle.html">handle</a> <a class="el" href="structbase.html">base</a>, bool isLocal)</td></tr>
<tr class="separator:a1a183883bc97bb26079701a8237e1896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7596976914c0d0d2e36b27a4686a62"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:a9c7596976914c0d0d2e36b27a4686a62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classexception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a9c7596976914c0d0d2e36b27a4686a62">register_exception</a> (<a class="el" href="classhandle.html">handle</a> <a class="el" href="structscope.html">scope</a>, const char *<a class="el" href="structname.html">name</a>, <a class="el" href="classhandle.html">handle</a> <a class="el" href="structbase.html">base</a>=PyExc_Exception)</td></tr>
<tr class="separator:a9c7596976914c0d0d2e36b27a4686a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d58399411361952333bbc791065588"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:a81d58399411361952333bbc791065588"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classexception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a81d58399411361952333bbc791065588">register_local_exception</a> (<a class="el" href="classhandle.html">handle</a> <a class="el" href="structscope.html">scope</a>, const char *<a class="el" href="structname.html">name</a>, <a class="el" href="classhandle.html">handle</a> <a class="el" href="structbase.html">base</a>=PyExc_Exception)</td></tr>
<tr class="separator:a81d58399411361952333bbc791065588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b87fe87c59169cf92bc95725f8a057"><td class="memItemLeft" align="right" valign="top"><a class="el" href="detail_2common_8h.html#a1fb186b7494d5c576d902c0730ecbb71">PYBIND11_NOINLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a87b87fe87c59169cf92bc95725f8a057">print</a> (const <a class="el" href="classtuple.html">tuple</a> &amp;<a class="el" href="classargs.html">args</a>, const <a class="el" href="classdict.html">dict</a> &amp;<a class="el" href="classkwargs.html">kwargs</a>)</td></tr>
<tr class="separator:a87b87fe87c59169cf92bc95725f8a057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d68b02745a7821c256c0642fb096c9"><td class="memTemplParams" colspan="2">template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </td></tr>
<tr class="memitem:a09d68b02745a7821c256c0642fb096c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a09d68b02745a7821c256c0642fb096c9">print</a> (Args &amp;&amp;...<a class="el" href="classargs.html">args</a>)</td></tr>
<tr class="separator:a09d68b02745a7821c256c0642fb096c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15e1d72d12f9a5fd1d7a3b29a7ac76a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfunction.html">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#ac15e1d72d12f9a5fd1d7a3b29a7ac76a">get_type_override</a> (const void *this_ptr, const <a class="el" href="structtype__info.html">type_info</a> *this_type, const char *<a class="el" href="structname.html">name</a>)</td></tr>
<tr class="separator:ac15e1d72d12f9a5fd1d7a3b29a7ac76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8cda8d00f1ec74bba3ed663dfa4e71"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7e8cda8d00f1ec74bba3ed663dfa4e71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfunction.html">function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a7e8cda8d00f1ec74bba3ed663dfa4e71">get_override</a> (const T *this_ptr, const char *<a class="el" href="structname.html">name</a>)</td></tr>
<tr class="separator:a7e8cda8d00f1ec74bba3ed663dfa4e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e918cccfeeabbbe9b1a42bba6b30a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfunction.html">function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a9e918cccfeeabbbe9b1a42bba6b30a42">get_type_overload</a> (const void *this_ptr, const detail::type_info *this_type, const char *<a class="el" href="structname.html">name</a>)</td></tr>
<tr class="separator:a9e918cccfeeabbbe9b1a42bba6b30a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5733211206597cdff171d9d43d8332"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e5733211206597cdff171d9d43d8332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfunction.html">function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="pybind11_8h.html#a6e5733211206597cdff171d9d43d8332">get_overload</a> (const T *this_ptr, const char *<a class="el" href="structname.html">name</a>)</td></tr>
<tr class="separator:a6e5733211206597cdff171d9d43d8332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a2fd9db526f4b1c2d8b4864eb4f2b1eb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_COMPAT_STRDUP&#160;&#160;&#160;strdup</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a91fd1ef72c39ba18ce5223e17d8a1caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_ENUM_OP_CONV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">m_base.attr(op) = <a class="code" href="classcpp__function.html">cpp_function</a>(                                                               \</div>
<div class="line">        [](<span class="keyword">const</span> <span class="keywordtype">object</span> &amp;a_, <span class="keyword">const</span> <span class="keywordtype">object</span> &amp;b_) {                                                  \</div>
<div class="line">            int_ a(a_), b(b_);                                                                    \</div>
<div class="line">            return expr;                                                                          \</div>
<div class="line">        },                                                                                        \</div>
<div class="line">        name(op),                                                                                 \</div>
<div class="line">        is_method(m_base),                                                                        \</div>
<div class="line">        arg(<span class="stringliteral">&quot;other&quot;</span>))</div>
<div class="ttc" id="classcpp__function_html"><div class="ttname"><a href="classcpp__function.html">cpp_function</a></div><div class="ttdoc">Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object. </div><div class="ttdef"><b>Definition:</b> pybind11.h:82</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1af9d4d51bae345dfc06b6c6fcfd9fdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_ENUM_OP_CONV_LHS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">m_base.attr(op) = <a class="code" href="classcpp__function.html">cpp_function</a>(                                                               \</div>
<div class="line">        [](<span class="keyword">const</span> <span class="keywordtype">object</span> &amp;a_, <span class="keyword">const</span> <span class="keywordtype">object</span> &amp;b) {                                                   \</div>
<div class="line">            int_ a(a_);                                                                           \</div>
<div class="line">            return expr;                                                                          \</div>
<div class="line">        },                                                                                        \</div>
<div class="line">        name(op),                                                                                 \</div>
<div class="line">        is_method(m_base),                                                                        \</div>
<div class="line">        arg(<span class="stringliteral">&quot;other&quot;</span>))</div>
<div class="ttc" id="classcpp__function_html"><div class="ttname"><a href="classcpp__function.html">cpp_function</a></div><div class="ttdoc">Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object. </div><div class="ttdef"><b>Definition:</b> pybind11.h:82</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adade02474502609b96c61b2054218bcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_ENUM_OP_STRICT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">strict_behavior&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">m_base.attr(op) = <a class="code" href="classcpp__function.html">cpp_function</a>(                                                               \</div>
<div class="line">        [](<span class="keyword">const</span> <span class="keywordtype">object</span> &amp;a, <span class="keyword">const</span> <span class="keywordtype">object</span> &amp;b) {                                                    \</div>
<div class="line">            if (!<a class="code" href="classtype.html#a44e283cae5fbd122bb38ee1db34eacdc">type::handle_of</a>(a).is(<a class="code" href="classtype.html#a44e283cae5fbd122bb38ee1db34eacdc">type::handle_of</a>(b)))                                       \</div>
<div class="line">                strict_behavior; <span class="comment">/* NOLINT(bugprone-macro-parentheses) */</span>                         \</div>
<div class="line">            return expr;                                                                          \</div>
<div class="line">        },                                                                                        \</div>
<div class="line">        name(op),                                                                                 \</div>
<div class="line">        is_method(m_base),                                                                        \</div>
<div class="line">        arg(<span class="stringliteral">&quot;other&quot;</span>))</div>
<div class="ttc" id="classcpp__function_html"><div class="ttname"><a href="classcpp__function.html">cpp_function</a></div><div class="ttdoc">Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object. </div><div class="ttdef"><b>Definition:</b> pybind11.h:82</div></div>
<div class="ttc" id="classtype_html_a44e283cae5fbd122bb38ee1db34eacdc"><div class="ttname"><a href="classtype.html#a44e283cae5fbd122bb38ee1db34eacdc">type::handle_of</a></div><div class="ttdeci">static handle handle_of()</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab9c836caf81bd65cf45e924bbd70eccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_HAS_STD_LAUNDER&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a554e6c4e025a0a1a1d8b30998144e386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERLOAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#a676997b992463eaa9f402b33a8aca82f">PYBIND11_OVERRIDE</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), fn, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad225e789a43a99757532d624f794b377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERLOAD_INT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structname.html">name</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">PYBIND11_OVERRIDE_IMPL</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="el" href="structname.html">name</a>, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a5ebc119f4e7ca7ccb05d9d1f64d547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERLOAD_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structname.html">name</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#aaa9a375d2743469e77032be644eb2c6d">PYBIND11_OVERRIDE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="el" href="structname.html">name</a>, fn, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf72084f40e31c334fd2d2b0161e959b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERLOAD_PURE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#a3cd1c7b6ad2aad2fc781c337c8adc2d1">PYBIND11_OVERRIDE_PURE</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), fn, __VA_ARGS__);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52b952e976930f2149eec9d0eb450100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERLOAD_PURE_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structname.html">name</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#ab61d0f2218e6017d8eb42eef8731c921">PYBIND11_OVERRIDE_PURE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="el" href="structname.html">name</a>, fn, __VA_ARGS__);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a676997b992463eaa9f402b33a8aca82f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERRIDE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#aaa9a375d2743469e77032be644eb2c6d">PYBIND11_OVERRIDE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), #fn, fn, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">\rst
Macro to populate the virtual method in the trampoline class. This macro tries to look up the method
from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
the appropriate type. This macro should be used if the method name in C and in Python are identical.
See :ref:`overriding_virtuals` for more information.

.. code-block:: cpp

  class PyAnimal : public Animal {
  public:
</pre><p> Inherit the constructors using <a class="el" href="structAnimal.html#af163de0cc8414e7f3ae8a18c848c42cc">Animal::Animal</a>;</p>
<p>Trampoline (need one for each virtual function) std::string go(int n_times) override { PYBIND11_OVERRIDE_PURE( std::string, // Return type (ret_type) <a class="el" href="structAnimal.html">Animal</a>, // Parent class (cname) go, // Name of function in C++ (must match Python name) (fn) n_times // Argument(s) (...) ); } };  </p>

</div>
</div>
<a class="anchor" id="a4cc6ec674e602ee43d9e1d4b5caf316f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERRIDE_IMPL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structname.html">name</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                                          \</div>
<div class="line">        pybind11::gil_scoped_acquire gil;                                                         \</div>
<div class="line">        pybind11::function <span class="keyword">override</span>                                                               \</div>
<div class="line">            = <a class="code" href="pybind11_8h.html#a7e8cda8d00f1ec74bba3ed663dfa4e71">pybind11::get_override</a>(static_cast&lt;const cname *&gt;(<span class="keyword">this</span>), <a class="code" href="structname.html">name</a>);                     \</div>
<div class="line">        if (<span class="keyword">override</span>) {                                                                           \</div>
<div class="line">            auto o = <span class="keyword">override</span>(__VA_ARGS__);                                                       \</div>
<div class="line">            if (<a class="code" href="namespacetest__callbacks.html#a9e87722eddd519b2bd0d4bd5874ccb2b">pybind11::detail::cast_is_temporary_value_reference&lt;ret_type&gt;::value</a>) {           \</div>
<div class="line">                static pybind11::detail::override_caster_t&lt;ret_type&gt; caster;                      \</div>
<div class="line">                return pybind11::detail::cast_ref&lt;ret_type&gt;(std::move(o), caster);                \</div>
<div class="line">            }                                                                                     \</div>
<div class="line">            return pybind11::detail::cast_safe&lt;ret_type&gt;(std::move(o));                           \</div>
<div class="line">        }                                                                                         \</div>
<div class="line">    } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
<div class="ttc" id="pybind11_8h_html_a7e8cda8d00f1ec74bba3ed663dfa4e71"><div class="ttname"><a href="pybind11_8h.html#a7e8cda8d00f1ec74bba3ed663dfa4e71">get_override</a></div><div class="ttdeci">function get_override(const T *this_ptr, const char *name)</div><div class="ttdef"><b>Definition:</b> pybind11.h:2373</div></div>
<div class="ttc" id="namespacetest__callbacks_html_a9e87722eddd519b2bd0d4bd5874ccb2b"><div class="ttname"><a href="namespacetest__callbacks.html#a9e87722eddd519b2bd0d4bd5874ccb2b">test_callbacks.value</a></div><div class="ttdeci">value</div><div class="ttdef"><b>Definition:</b> test_callbacks.py:149</div></div>
<div class="ttc" id="structname_html"><div class="ttname"><a href="structname.html">name</a></div><div class="ttdoc">Annotation for function names. </div><div class="ttdef"><b>Definition:</b> attr.h:44</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaa9a375d2743469e77032be644eb2c6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERRIDE_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structname.html">name</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { <a class="code" href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">\</a></div>
<div class="line"><a class="code" href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">        PYBIND11_OVERRIDE_IMPL</a>(<a class="code" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="code" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="code" href="structname.html">name</a>, __VA_ARGS__); \</div>
<div class="line">        return cname::fn(__VA_ARGS__); \</div>
<div class="line">    } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
<div class="ttc" id="structname_html"><div class="ttname"><a href="structname.html">name</a></div><div class="ttdoc">Annotation for function names. </div><div class="ttdef"><b>Definition:</b> attr.h:44</div></div>
<div class="ttc" id="pybind11_8h_html_a4cc6ec674e602ee43d9e1d4b5caf316f"><div class="ttname"><a href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">PYBIND11_OVERRIDE_IMPL</a></div><div class="ttdeci">#define PYBIND11_OVERRIDE_IMPL(ret_type, cname, name,...)</div><div class="ttdef"><b>Definition:</b> pybind11.h:2378</div></div>
<div class="ttc" id="cast_8h_html_abf638a034b5ed51437f70d736e85c0a6"><div class="ttname"><a href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a></div><div class="ttdeci">#define PYBIND11_TYPE(...)</div></div>
</div><!-- fragment --><pre class="fragment">\rst
Macro to populate the virtual method in the trampoline class. This macro tries to look up a method named 'fn'
from the Python side, deals with the :ref:`gil` and necessary argument conversions to call this method and return
the appropriate type. See :ref:`overriding_virtuals` for more information. This macro should be used when the method
name in C is not the same as the method name in Python. For example with `__str__`.

.. code-block:: cpp

  std::string toString() override {
    PYBIND11_OVERRIDE_NAME(
        std::string, // Return type (ret_type)
        Animal,      // Parent class (cname)
        "__str__",   // Name of method in Python (name)
        toString,    // Name of function in C++ (fn)
    );
  }
</pre>  
</div>
</div>
<a class="anchor" id="a3cd1c7b6ad2aad2fc781c337c8adc2d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERRIDE_PURE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="pybind11_8h.html#ab61d0f2218e6017d8eb42eef8731c921">PYBIND11_OVERRIDE_PURE_NAME</a>(<a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="el" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), #fn, fn, __VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">\rst
Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERRIDE`, except that it throws
if no override can be found.
</pre>  
</div>
</div>
<a class="anchor" id="ab61d0f2218e6017d8eb42eef8731c921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_OVERRIDE_PURE_NAME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="structname.html">name</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { <a class="code" href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">\</a></div>
<div class="line"><a class="code" href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">        PYBIND11_OVERRIDE_IMPL</a>(<a class="code" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(ret_type), <a class="code" href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a>(cname), <a class="code" href="structname.html">name</a>, __VA_ARGS__); <a class="code" href="detail_2common_8h.html#a45d9ed7ed9d645bffc6436007a58b6e2">\</a></div>
<div class="line"><a class="code" href="detail_2common_8h.html#a45d9ed7ed9d645bffc6436007a58b6e2">        pybind11::pybind11_fail</a>(<span class="stringliteral">&quot;Tried to call pure virtual function \&quot;&quot;</span> <a class="code" href="detail_2common_8h.html#ab822e781bd1668e8bd7bd3de1b610978">PYBIND11_STRINGIFY</a>(cname) <span class="stringliteral">&quot;::&quot;</span> <a class="code" href="structname.html">name</a> <span class="stringliteral">&quot;\&quot;&quot;</span>); \</div>
<div class="line">    } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
<div class="ttc" id="detail_2common_8h_html_ab822e781bd1668e8bd7bd3de1b610978"><div class="ttname"><a href="detail_2common_8h.html#ab822e781bd1668e8bd7bd3de1b610978">PYBIND11_STRINGIFY</a></div><div class="ttdeci">#define PYBIND11_STRINGIFY(x)</div><div class="ttdef"><b>Definition:</b> common.h:315</div></div>
<div class="ttc" id="structname_html"><div class="ttname"><a href="structname.html">name</a></div><div class="ttdoc">Annotation for function names. </div><div class="ttdef"><b>Definition:</b> attr.h:44</div></div>
<div class="ttc" id="pybind11_8h_html_a4cc6ec674e602ee43d9e1d4b5caf316f"><div class="ttname"><a href="pybind11_8h.html#a4cc6ec674e602ee43d9e1d4b5caf316f">PYBIND11_OVERRIDE_IMPL</a></div><div class="ttdeci">#define PYBIND11_OVERRIDE_IMPL(ret_type, cname, name,...)</div><div class="ttdef"><b>Definition:</b> pybind11.h:2378</div></div>
<div class="ttc" id="detail_2common_8h_html_a45d9ed7ed9d645bffc6436007a58b6e2"><div class="ttname"><a href="detail_2common_8h.html#a45d9ed7ed9d645bffc6436007a58b6e2">pybind11_fail</a></div><div class="ttdeci">PyExc_RuntimeError[[noreturn]] PYBIND11_NOINLINE void pybind11_fail(const char *reason)</div><div class="ttdoc">Used internally. </div><div class="ttdef"><b>Definition:</b> common.h:837</div></div>
<div class="ttc" id="cast_8h_html_abf638a034b5ed51437f70d736e85c0a6"><div class="ttname"><a href="cast_8h.html#abf638a034b5ed51437f70d736e85c0a6">PYBIND11_TYPE</a></div><div class="ttdeci">#define PYBIND11_TYPE(...)</div></div>
</div><!-- fragment --><pre class="fragment">\rst
Macro for pure virtual functions, this function is identical to :c:macro:`PYBIND11_OVERRIDE_NAME`, except that it
throws if no override can be found.
</pre>  
</div>
</div>
<a class="anchor" id="a89ef98b3c1b0cd785d6f37dad8fff8b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_STD_LAUNDER</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acc16e5b178730313f1372d6e1be4e414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PYBIND11_THROW&#160;&#160;&#160;throw type_error(&quot;Expected an enumeration of matching type!&quot;);</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a117a9d990aaecff5ed8c9106fefc61aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="pybind11_8h.html#a117a9d990aaecff5ed8c9106fefc61aa">equivalent_integer_t</a> =  typename <a class="el" href="structequivalent__integer.html">equivalent_integer</a>&lt;std::is_signed&lt;IntLike&gt;::value, sizeof(IntLike)&gt;::<a class="el" href="classtype.html">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a901866f667bab56f0f47d93c42afb6fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="pybind11_8h.html#a901866f667bab56f0f47d93c42afb6fc">module</a> =  <a class="el" href="classmodule__.html">module_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aefe75675661f805f43391c0f7d00e23c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add_class_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classobject.html">object</a> &amp;&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcpp__function.html">cpp_function</a> &amp;&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa29009830196890060d446644b1f7cec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;decltype(<a class="el" href="structinternals.html#a6148bb4956e17d8a61f410cac7227d04">internals::registered_types_py</a>)::<a class="el" href="classiterator.html">iterator</a>, bool&gt; all_type_info_get_cache </td>
          <td>(</td>
          <td class="paramtype">PyTypeObject *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a371d331d7073d8abc4ca0d54174e3fdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool apply_exception_translators </td>
          <td>(</td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="internals_8h.html#a596d5eacb6a7f656d2fa4a241636e223">ExceptionTranslator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>translators</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f9edb48e1b7e9f3cf1dfa835cc39be2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , enable_if_t&lt; has_operator_delete&lt; T &gt;::value, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void call_operator_delete </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call class-specific delete if it exists or global otherwise. Can also be an overload set. </p>

</div>
</div>
<a class="anchor" id="a5e61d624540777bbf68662f0c0da0bbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void call_operator_delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c8fe77ae59b4c20905c50b4221072b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstr.html">str</a> enum_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e05149e1a3c61637211fd554bb856f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexception.html">exception</a>&lt;CppException&gt;&amp; get_exception_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e5733211206597cdff171d9d43d8332"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfunction.html">function</a> get_overload </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e8cda8d00f1ec74bba3ed663dfa4e71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfunction.html">function</a> get_override </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to retrieve a python method by the provided name from the instance pointed to by the this_ptr.</p>
<p>:this_ptr: The pointer to the object the overridden method should be retrieved for. This should be the first non-trampoline class encountered in the inheritance chain. :name: The name of the overridden Python method to retrieve. :return: The Python method by this name from the object or an empty function wrapper.  </p>

</div>
</div>
<a class="anchor" id="a9e918cccfeeabbbe9b1a42bba6b30a42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfunction.html">function</a> get_type_overload </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const detail::type_info *&#160;</td>
          <td class="paramname"><em>this_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac15e1d72d12f9a5fd1d7a3b29a7ac76a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfunction.html">function</a> get_type_override </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtype__info.html">type_info</a> *&#160;</td>
          <td class="paramname"><em>this_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a271a0a8cc9839658c668492cbaa1035a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputType , typename OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void implicitly_convertible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8c2b15c53478c1154ec995f5f83faf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::initimpl::constructor&lt;Args...&gt; init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds an existing constructor taking arguments Args... </p>

</div>
</div>
<a class="anchor" id="a1ca0a3cdc2264eb2b0d36acd762c8bae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func , typename Ret  = detail::initimpl::factory&lt;Func&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ret init </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds a factory function as a constructor. </p>

</div>
</div>
<a class="anchor" id="a144961765ca31801e21d87651871934c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CFunc , typename AFunc , typename Ret  = detail::initimpl::factory&lt;CFunc, AFunc&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ret init </td>
          <td>(</td>
          <td class="paramtype">CFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dual-argument factory function: the first function is called when no alias is needed, the second when an alias is needed (i.e. due to python-side inheritance). Arguments must be identical. </p>

</div>
</div>
<a class="anchor" id="a39d58e6f734e067663b055f7da3b0f2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::initimpl::alias_constructor&lt;Args...&gt; init_alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <code>init&lt;Args...&gt;()</code>, but the instance is always constructed through the alias class (even when not inheriting on the Python side). </p>

</div>
</div>
<a class="anchor" id="a5d0b13e3a890001e99f724fef9d285de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="detail_2common_8h.html#a1fb186b7494d5c576d902c0730ecbb71">PYBIND11_NOINLINE</a> void keep_alive_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>nurse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>patient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1bda75120c8e859c75dfd2f5a266c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="detail_2common_8h.html#a1fb186b7494d5c576d902c0730ecbb71">PYBIND11_NOINLINE</a> void keep_alive_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>&#160;</td>
          <td class="paramname"><em>Nurse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="detail_2common_8h.html#a801d6a451a01953ef8cbae6feb6a3638">size_t</a>&#160;</td>
          <td class="paramname"><em>Patient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function_call &amp;&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6d3654deacdd79bbdc1feb82955fd30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = typename detail::iterator_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator.html">iterator</a> make_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a python iterator from a first and past-the-end C++ InputIterator. </p>

</div>
</div>
<a class="anchor" id="aa4568dafc7828fa924d63fd6e8e77171"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator.html">iterator</a> make_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an iterator over values of an stl container or other container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a class="anchor" id="a416a9cc6f9891390c28bcba008d58225"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Access , return_value_policy Policy, typename Iterator , typename Sentinel , typename ValueType , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator.html">iterator</a> make_iterator_impl </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adba3c96a10f754eb5d59f83aef2b364b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = typename detail::iterator_key_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator.html">iterator</a> make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a python iterator over the keys (<code>.first</code>) of a iterator over pairs from a first and past-the-end InputIterator. </p>

</div>
</div>
<a class="anchor" id="abe5c4912de4a5bd91b09420b946dc5e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator.html">iterator</a> make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an iterator over the keys (<code>.first</code>) of a stl map-like container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a class="anchor" id="a0c05cc3bd4da2516057ca76ab7654dcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = typename detail::iterator_value_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator.html">iterator</a> make_value_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a python iterator over the values (<code>.second</code>) of a iterator over pairs from a first and past-the-end InputIterator. </p>

</div>
</div>
<a class="anchor" id="a253e7eb1e5fe98a584738fbd34c70f61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classiterator.html">iterator</a> make_value_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an iterator over the values (<code>.second</code>) of a stl map-like container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a class="anchor" id="a133120592be1caf7036580978b5bd6dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto method_adaptor </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; decltype(std::forward&lt;F&gt;(f)) </td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a pointer to a member function, cast it to its <code>Derived</code> version. Forward everything else unchanged. </p>

</div>
</div>
<a class="anchor" id="adb45bb8178cd55c41b0f0d84bde00cfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename Return , typename Class , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto method_adaptor </td>
          <td>(</td>
          <td class="paramtype">Return(Class::*)(Args...)&#160;</td>
          <td class="paramname"><em>pmf</em></td><td>)</td>
          <td> -&gt; Return (Derived::*)(Args...) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a17d308bb5b6a2dbeb02cd90d90876562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GetState , typename SetState &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::initimpl::pickle_factory&lt;GetState, SetState&gt; pickle </td>
          <td>(</td>
          <td class="paramtype">GetState &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SetState &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds pickling functions <code>__getstate__</code> and <code>__setstate__</code> and ensures that the type returned by <code>__getstate__</code> is the same as the argument accepted by <code>__setstate__</code>. </p>

</div>
</div>
<a class="anchor" id="a87b87fe87c59169cf92bc95725f8a057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="detail_2common_8h.html#a1fb186b7494d5c576d902c0730ecbb71">PYBIND11_NOINLINE</a> void print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtuple.html">tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdict.html">dict</a> &amp;&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a09d68b02745a7821c256c0642fb096c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;return_value_policy policy = return_value_policy::automatic_reference, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9c7596976914c0d0d2e36b27a4686a62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexception.html">exception</a>&lt;CppException&gt;&amp; register_exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>PyExc_Exception</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a Python exception in <code>m</code> of the given <code>name</code> and installs a translator to translate the C++ exception to the created Python exception using the what() method. This is intended for simple exception translations; for more complex translation, register the exception object and translator directly. </p>

</div>
</div>
<a class="anchor" id="a1a183883bc97bb26079701a8237e1896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexception.html">exception</a>&lt;CppException&gt;&amp; register_exception_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLocal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae13b0934aa2da46dd6969a0ea44adfed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void register_exception_translator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="internals_8h.html#a596d5eacb6a7f656d2fa4a241636e223">ExceptionTranslator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>translator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81d58399411361952333bbc791065588"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classexception.html">exception</a>&lt;CppException&gt;&amp; register_local_exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandle.html">handle</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>PyExc_Exception</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a Python exception in <code>m</code> of the given <code>name</code> and installs a translator to translate the C++ exception to the created Python exception using the what() method. This translator will only be used for exceptions that are thrown in this module and will be tried before global exception translators, including those registered with register_exception. This is intended for simple exception translations; for more complex translation, register the exception object and translator directly. </p>

</div>
</div>
<a class="anchor" id="a39b50172e54731480feea10ec204f003"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void register_local_exception_translator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="internals_8h.html#a596d5eacb6a7f656d2fa4a241636e223">ExceptionTranslator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>translator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new module-local exception translator. Locally registered functions will be tried before any globally registered exception translators, which will only be invoked if the module-local handlers do not deal with the exception. </p>

</div>
</div>
<a class="anchor" id="ae55b858834fdd3c6adb5e8b9615b49b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = void_t&lt;decltype(static_cast&lt;void *(*)(size_t)&gt;(T::operator new))&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_operator_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtype__record.html">type_record</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the pointer to operator new if it exists. The cast is needed because it can be overloaded. </p>

</div>
</div>
<a class="anchor" id="a32d62802b102a8ac8362eeef769aaad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void set_operator_new </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
